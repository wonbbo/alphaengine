# AlphaEngine v2 TRD --- Strategy Interface

생성일: 2026-02-20

본 문서는 AlphaEngine v2의 전략 인터페이스를 TRD 수준으로 고정한다.

------------------------------------------------------------------------

# 1. 설계 원칙

1. **전략은 거래소 API를 직접 호출하지 않는다.**
   - 전략 → Decision → Command → Executor → Exchange

2. **전략은 읽기 전용 Context를 받는다.**
   - 현재 포지션, 잔고, 오픈 주문, 캔들 등

3. **전략은 Command만 반환한다.**
   - PlaceOrder, CancelOrder, ClosePosition 등

4. **전략 교체 시 코어 수정이 필요 없다.**
   - 플러그인 구조

5. **전략 상태는 별도 저장소에 관리한다.**
   - 재시작 시 복구 가능

------------------------------------------------------------------------

# 2. 전략 인터페이스

## 2.1 기본 구조

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Protocol
from decimal import Decimal
from datetime import datetime


@dataclass(frozen=True)
class StrategyMeta:
    """전략 메타데이터"""
    name: str
    version: str
    hash: str  # 코드 해시 (변경 감지)


@dataclass(frozen=True)
class Scope:
    """거래 범위"""
    exchange: str      # BINANCE
    venue: str         # FUTURES | SPOT
    account_id: str    # 계좌 ID
    symbol: str        # XRPUSDT
    mode: str          # PRODUCTION | TESTNET


@dataclass
class Position:
    """현재 포지션"""
    side: str | None      # LONG | SHORT | None
    qty: Decimal          # 수량
    entry_price: Decimal  # 평균 진입가
    unrealized_pnl: Decimal
    leverage: int
    margin_type: str      # ISOLATED | CROSS


@dataclass
class Balance:
    """잔고"""
    asset: str
    free: Decimal
    locked: Decimal
    
    @property
    def total(self) -> Decimal:
        return self.free + self.locked


@dataclass
class OpenOrder:
    """오픈 주문"""
    exchange_order_id: str
    client_order_id: str | None
    side: str
    order_type: str
    original_qty: Decimal
    executed_qty: Decimal
    price: Decimal | None
    stop_price: Decimal | None
    status: str
    created_at: datetime


@dataclass
class Bar:
    """캔들스틱"""
    ts: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal


@dataclass(frozen=True)
class StrategyTickContext:
    """전략에 전달되는 읽기 전용 컨텍스트"""
    
    # 범위
    scope: Scope
    
    # 현재 시각
    now: datetime
    
    # 계좌 상태
    position: Position | None
    balances: dict[str, Balance]  # asset -> Balance
    open_orders: list[OpenOrder]
    
    # 시장 데이터
    bars: list[Bar]        # 최근 N개 캔들 (시간순)
    current_price: Decimal | None
    
    # 전략 상태 (재시작 복구용)
    strategy_state: dict[str, Any]
    
    # 엔진 상태
    engine_mode: str  # RUNNING | PAUSED | SAFE
    
    # 읽기 전용 보장
    def __setattr__(self, name, value):
        if hasattr(self, name):
            raise AttributeError("StrategyTickContext is immutable")
        super().__setattr__(name, value)


class CommandEmitter(Protocol):
    """Command 발행 프로토콜"""
    
    def place_order(
        self,
        side: str,
        order_type: str,
        qty: Decimal,
        price: Decimal | None = None,
        stop_price: Decimal | None = None,
        reduce_only: bool = False,
        time_in_force: str = "GTC",
        intent: str | None = None,  # ENTRY | EXIT | SL | TP
    ) -> str:
        """주문 발행. command_id 반환."""
        ...
    
    def cancel_order(
        self,
        exchange_order_id: str | None = None,
        client_order_id: str | None = None,
    ) -> str:
        """주문 취소. command_id 반환."""
        ...
    
    def cancel_all(self) -> str:
        """모든 주문 취소. command_id 반환."""
        ...
    
    def close_position(
        self,
        mode: str = "MARKET",
        reason: str | None = None,
    ) -> str:
        """포지션 청산. command_id 반환."""
        ...
    
    def update_state(self, key: str, value: Any) -> None:
        """전략 상태 업데이트 (재시작 시 복구)."""
        ...


class Strategy(ABC):
    """전략 기본 클래스"""
    
    @property
    @abstractmethod
    def meta(self) -> StrategyMeta:
        """전략 메타데이터"""
        pass
    
    @abstractmethod
    async def on_tick(
        self,
        ctx: StrategyTickContext,
        emit: CommandEmitter,
    ) -> None:
        """
        매 tick마다 호출되는 전략 로직.
        
        Args:
            ctx: 읽기 전용 컨텍스트 (포지션, 잔고, 캔들 등)
            emit: Command 발행 인터페이스
        
        주의:
            - ctx는 읽기 전용. 직접 수정 불가.
            - emit을 통해서만 주문/취소 수행.
            - 거래소 API 직접 호출 금지.
        """
        pass
    
    async def on_start(self, ctx: StrategyTickContext) -> None:
        """전략 시작 시 호출 (선택)"""
        pass
    
    async def on_stop(self) -> None:
        """전략 종료 시 호출 (선택)"""
        pass
```

------------------------------------------------------------------------

# 3. 예제 전략

## 3.1 SMA 크로스 전략

```python
from decimal import Decimal
from strategies.base import Strategy, StrategyMeta, StrategyTickContext, CommandEmitter


class SmaCrossStrategy(Strategy):
    """단순 이동평균 교차 전략"""
    
    def __init__(self, fast_period: int = 10, slow_period: int = 20):
        self.fast_period = fast_period
        self.slow_period = slow_period
    
    @property
    def meta(self) -> StrategyMeta:
        return StrategyMeta(
            name="sma_cross",
            version="1.0.0",
            hash="abc123",
        )
    
    async def on_tick(
        self,
        ctx: StrategyTickContext,
        emit: CommandEmitter,
    ) -> None:
        # 엔진 상태 확인
        if ctx.engine_mode != "RUNNING":
            return
        
        # 캔들 데이터 확인
        if len(ctx.bars) < self.slow_period:
            return
        
        # SMA 계산
        closes = [bar.close for bar in ctx.bars]
        fast_sma = self._sma(closes, self.fast_period)
        slow_sma = self._sma(closes, self.slow_period)
        
        # 이전 SMA 값 (상태에서 복구)
        prev_fast = ctx.strategy_state.get("prev_fast")
        prev_slow = ctx.strategy_state.get("prev_slow")
        
        # 상태 업데이트
        emit.update_state("prev_fast", float(fast_sma))
        emit.update_state("prev_slow", float(slow_sma))
        
        if prev_fast is None or prev_slow is None:
            return
        
        # 교차 감지
        golden_cross = prev_fast <= prev_slow and fast_sma > slow_sma
        dead_cross = prev_fast >= prev_slow and fast_sma < slow_sma
        
        position = ctx.position
        has_position = position and position.qty > 0
        
        # 매수 신호 (골든 크로스)
        if golden_cross and not has_position:
            # 리스크 기반 수량 계산
            usdt_balance = ctx.balances.get("USDT")
            if usdt_balance:
                # 전체 자금의 2% 리스크
                risk_amount = usdt_balance.free * Decimal("0.02")
                qty = risk_amount / ctx.current_price
                
                emit.place_order(
                    side="BUY",
                    order_type="MARKET",
                    qty=qty,
                    intent="ENTRY",
                )
        
        # 매도 신호 (데드 크로스)
        elif dead_cross and has_position:
            emit.close_position(
                mode="MARKET",
                reason="dead_cross",
            )
    
    def _sma(self, values: list[Decimal], period: int) -> Decimal:
        """단순 이동평균 계산"""
        return sum(values[-period:]) / period
```

## 3.2 그리드 전략

```python
from decimal import Decimal
from strategies.base import Strategy, StrategyMeta, StrategyTickContext, CommandEmitter


class GridStrategy(Strategy):
    """그리드 트레이딩 전략"""
    
    def __init__(
        self,
        grid_size: int = 10,
        grid_spacing: Decimal = Decimal("0.01"),  # 1%
        qty_per_grid: Decimal = Decimal("100"),
    ):
        self.grid_size = grid_size
        self.grid_spacing = grid_spacing
        self.qty_per_grid = qty_per_grid
    
    @property
    def meta(self) -> StrategyMeta:
        return StrategyMeta(
            name="grid",
            version="1.0.0",
            hash="def456",
        )
    
    async def on_tick(
        self,
        ctx: StrategyTickContext,
        emit: CommandEmitter,
    ) -> None:
        if ctx.engine_mode != "RUNNING":
            return
        
        if not ctx.current_price:
            return
        
        # 그리드 레벨 계산
        base_price = ctx.strategy_state.get("base_price")
        if not base_price:
            # 첫 실행: 현재가를 기준으로 그리드 설정
            base_price = float(ctx.current_price)
            emit.update_state("base_price", base_price)
        
        base_price = Decimal(str(base_price))
        
        # 현재 오픈 주문 확인
        open_order_prices = {
            o.price for o in ctx.open_orders if o.price
        }
        
        # 그리드 레벨별 주문 확인 및 생성
        for i in range(-self.grid_size // 2, self.grid_size // 2 + 1):
            if i == 0:
                continue
            
            grid_price = base_price * (1 + self.grid_spacing * i)
            grid_price = round(grid_price, 4)  # 소수점 처리
            
            # 이미 주문이 있으면 스킵
            if grid_price in open_order_prices:
                continue
            
            # 가격이 현재가보다 낮으면 매수, 높으면 매도
            if grid_price < ctx.current_price:
                side = "BUY"
            else:
                side = "SELL"
            
            emit.place_order(
                side=side,
                order_type="LIMIT",
                qty=self.qty_per_grid,
                price=grid_price,
                time_in_force="GTC",
                intent="GRID",
            )
```

------------------------------------------------------------------------

# 4. Strategy Runner

## 4.1 구현

```python
import asyncio
import importlib
import hashlib
from typing import Any
from strategies.base import Strategy, StrategyTickContext, CommandEmitter, StrategyMeta


class StrategyRunner:
    """전략 실행 관리자"""
    
    def __init__(
        self,
        strategy_name: str,
        strategy_params: dict[str, Any],
        command_store: "CommandStore",
        state_store: "StateStore",
    ):
        self.strategy_name = strategy_name
        self.strategy_params = strategy_params
        self.command_store = command_store
        self.state_store = state_store
        self.strategy: Strategy | None = None
    
    async def load(self) -> StrategyMeta:
        """전략 로드"""
        module = importlib.import_module(f"strategies.{self.strategy_name}")
        strategy_class = getattr(module, "Strategy")
        self.strategy = strategy_class(**self.strategy_params)
        return self.strategy.meta
    
    async def on_tick(self, ctx: StrategyTickContext) -> list["Command"]:
        """전략 tick 실행"""
        if not self.strategy:
            return []
        
        # Command 수집기
        emitter = CommandEmitterImpl(
            scope=ctx.scope,
            command_store=self.command_store,
            state_store=self.state_store,
        )
        
        try:
            await self.strategy.on_tick(ctx, emitter)
        except Exception as e:
            # 전략 에러는 로깅하고 계속 진행
            logger.error(f"Strategy error: {e}")
        
        return emitter.get_commands()


class CommandEmitterImpl:
    """CommandEmitter 구현체"""
    
    def __init__(
        self,
        scope: "Scope",
        command_store: "CommandStore",
        state_store: "StateStore",
    ):
        self.scope = scope
        self.command_store = command_store
        self.state_store = state_store
        self._commands: list["Command"] = []
    
    def place_order(
        self,
        side: str,
        order_type: str,
        qty: Decimal,
        price: Decimal | None = None,
        stop_price: Decimal | None = None,
        reduce_only: bool = False,
        time_in_force: str = "GTC",
        intent: str | None = None,
    ) -> str:
        """주문 발행"""
        command_id = str(uuid4())
        client_order_id = f"ae-{command_id}"
        
        command = Command.new(
            command_type="PlaceOrder",
            actor_kind="STRATEGY",
            actor_id=f"strategy:{self.scope.symbol}",
            scope=self.scope,
            payload={
                "client_order_id": client_order_id,
                "side": side,
                "order_type": order_type,
                "qty": str(qty),
                "price": str(price) if price else None,
                "stop_price": str(stop_price) if stop_price else None,
                "reduce_only": reduce_only,
                "time_in_force": time_in_force,
                "tags": {"intent": intent} if intent else {},
            },
        )
        
        self._commands.append(command)
        return command_id
    
    def cancel_order(
        self,
        exchange_order_id: str | None = None,
        client_order_id: str | None = None,
    ) -> str:
        """주문 취소"""
        command_id = str(uuid4())
        
        command = Command.new(
            command_type="CancelOrder",
            actor_kind="STRATEGY",
            actor_id=f"strategy:{self.scope.symbol}",
            scope=self.scope,
            payload={
                "exchange_order_id": exchange_order_id,
                "client_order_id": client_order_id,
            },
        )
        
        self._commands.append(command)
        return command_id
    
    def cancel_all(self) -> str:
        """모든 주문 취소"""
        command_id = str(uuid4())
        
        command = Command.new(
            command_type="CancelAll",
            actor_kind="STRATEGY",
            actor_id=f"strategy:{self.scope.symbol}",
            scope=self.scope,
            payload={"reason": "strategy_requested"},
        )
        
        self._commands.append(command)
        return command_id
    
    def close_position(
        self,
        mode: str = "MARKET",
        reason: str | None = None,
    ) -> str:
        """포지션 청산"""
        command_id = str(uuid4())
        
        command = Command.new(
            command_type="ClosePosition",
            actor_kind="STRATEGY",
            actor_id=f"strategy:{self.scope.symbol}",
            scope=self.scope,
            payload={
                "mode": mode,
                "reason": reason,
            },
        )
        
        self._commands.append(command)
        return command_id
    
    def update_state(self, key: str, value: Any) -> None:
        """전략 상태 업데이트"""
        self.state_store.set(f"strategy:{key}", value)
    
    def get_commands(self) -> list["Command"]:
        """생성된 Command 반환"""
        return self._commands
```

------------------------------------------------------------------------

# 5. 전략 상태 관리

## 5.1 상태 저장소

```python
class StrategyStateStore:
    """전략 상태 저장소 (재시작 복구용)"""
    
    def __init__(self, db: AsyncSession, strategy_name: str):
        self.db = db
        self.strategy_name = strategy_name
        self._cache: dict[str, Any] = {}
    
    async def load(self) -> dict[str, Any]:
        """DB에서 상태 로드"""
        result = await self.db.execute(
            select(ConfigStore)
            .where(ConfigStore.key == f"strategy_state:{self.strategy_name}")
        )
        config = result.scalar_one_or_none()
        
        if config:
            self._cache = config.value_json
        else:
            self._cache = {}
        
        return self._cache
    
    def get(self, key: str) -> Any:
        """상태 조회"""
        return self._cache.get(key)
    
    def set(self, key: str, value: Any) -> None:
        """상태 설정"""
        self._cache[key] = value
    
    async def save(self) -> None:
        """DB에 상태 저장"""
        result = await self.db.execute(
            select(ConfigStore)
            .where(ConfigStore.key == f"strategy_state:{self.strategy_name}")
        )
        config = result.scalar_one_or_none()
        
        if config:
            config.value_json = self._cache
            config.updated_at = datetime.utcnow()
        else:
            config = ConfigStore(
                key=f"strategy_state:{self.strategy_name}",
                value_json=self._cache,
                version=1,
                updated_by="bot:strategy",
            )
            self.db.add(config)
        
        await self.db.commit()
```

## 5.2 Context 빌드

```python
async def build_strategy_context(
    projector: Projector,
    bar_store: BarStore,
    state_store: StrategyStateStore,
    scope: Scope,
    engine_mode: str,
) -> StrategyTickContext:
    """전략 컨텍스트 빌드"""
    
    # 포지션
    position_data = await projector.get_position(scope)
    position = Position(
        side=position_data.side,
        qty=position_data.qty,
        entry_price=position_data.entry_price,
        unrealized_pnl=position_data.unrealized_pnl,
        leverage=position_data.leverage,
        margin_type=position_data.margin_type,
    ) if position_data else None
    
    # 잔고
    balance_rows = await projector.get_balances(scope)
    balances = {
        b.asset: Balance(asset=b.asset, free=b.free, locked=b.locked)
        for b in balance_rows
    }
    
    # 오픈 주문
    order_rows = await projector.get_open_orders(scope)
    open_orders = [
        OpenOrder(
            exchange_order_id=o.exchange_order_id,
            client_order_id=o.client_order_id,
            side=o.side,
            order_type=o.order_type,
            original_qty=o.original_qty,
            executed_qty=o.executed_qty,
            price=o.price,
            stop_price=o.stop_price,
            status=o.status,
            created_at=o.created_at,
        )
        for o in order_rows
    ]
    
    # 캔들
    bars_data = await bar_store.get_recent(scope.symbol, limit=100)
    bars = [
        Bar(
            ts=b.ts,
            open=b.open,
            high=b.high,
            low=b.low,
            close=b.close,
            volume=b.volume,
        )
        for b in bars_data
    ]
    
    # 현재가
    current_price = bars[-1].close if bars else None
    
    # 전략 상태
    strategy_state = await state_store.load()
    
    return StrategyTickContext(
        scope=scope,
        now=datetime.utcnow(),
        position=position,
        balances=balances,
        open_orders=open_orders,
        bars=bars,
        current_price=current_price,
        strategy_state=strategy_state,
        engine_mode=engine_mode,
    )
```

------------------------------------------------------------------------

# 6. 전략 검증

## 6.1 검증 규칙

1. **meta 필수**: name, version, hash 필수
2. **on_tick 비동기**: async def on_tick(...)
3. **API 호출 금지**: emit 통해서만 주문
4. **예외 처리**: 전략 예외는 엔진에 영향 없음

## 6.2 검증 테스트

```python
async def test_strategy_interface():
    """전략 인터페이스 테스트"""
    
    strategy = SmaCrossStrategy(fast_period=5, slow_period=10)
    
    # meta 검증
    assert strategy.meta.name
    assert strategy.meta.version
    
    # ctx 생성
    ctx = StrategyTickContext(
        scope=Scope(...),
        now=datetime.utcnow(),
        position=None,
        balances={"USDT": Balance(asset="USDT", free=Decimal("1000"), locked=Decimal("0"))},
        open_orders=[],
        bars=[Bar(...) for _ in range(20)],
        current_price=Decimal("0.5"),
        strategy_state={},
        engine_mode="RUNNING",
    )
    
    # emit 모의
    emitter = MockCommandEmitter()
    
    # on_tick 실행
    await strategy.on_tick(ctx, emitter)
    
    # 검증
    commands = emitter.get_commands()
    # ... 검증 로직
```

------------------------------------------------------------------------

문서 종료

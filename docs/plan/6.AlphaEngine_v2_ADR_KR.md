# AlphaEngine v2 --- Architectural Decision Records (ADR)

생성일: 2026-02-20

본 문서는 AlphaEngine v2의 주요 아키텍처 결정을 기록한다.

------------------------------------------------------------------------

# ADR-001: Hybrid (WebSocket + REST) 방식 채택

## 컨텍스트

AlphaEngine v1은 REST Polling only 방식을 채택했다.
- 장점: 구현 단순, 상태 관리 용이, 안정적
- 단점: 체결 감지 지연 (1~30초), Rate Limit 부담

v2에서는 실시간성을 개선해야 한다.

## 결정

**Hybrid 방식 (WebSocket + REST Polling)**을 채택한다.

```
WebSocket: 실시간 힌트 (50~100ms)
REST:      최종 정합 보장 (30초~1분 간격)
```

## 이유

1. **WebSocket만 사용 시 문제점**
   - 연결 끊김 시 이벤트 누락 가능
   - 재연결 시 과거 이벤트 복구 불가
   - 네트워크 불안정 시 신뢰성 저하

2. **REST만 사용 시 문제점**
   - 체결 감지 지연
   - Rate Limit 부담

3. **Hybrid 장점**
   - 실시간성 확보 (WebSocket)
   - 안정성/정합성 확보 (REST)
   - Rate Limit 최적화 (WebSocket으로 대부분 처리, REST는 백업)

## 결과

- WebSocket Listener 컴포넌트 추가
- REST Reconciler 유지 (간격 조정)
- dedup_key로 이벤트 병합
- WebSocketState 상태머신 추가

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-002: SQLite (WAL 모드) 유지

## 컨텍스트

AlphaEngine v1은 SQLite를 사용했다.
- 장점: 단일 파일, 배포 단순, WAL 모드로 동시 읽기 가능, 설정 불필요
- 단점: 동시 쓰기 제한 (단일 Writer)

v2에서는 Bot과 Web이 동시에 DB에 접근한다.

## 결정

**SQLite (WAL 모드)**를 유지한다.

## 이유

1. **단순한 배포**
   - 별도 DB 서버 프로세스 불필요
   - 단일 파일로 백업/복원 용이

2. **WAL 모드로 동시 접근 지원**
   - 다중 Reader + 단일 Writer 지원
   - Bot이 Primary Writer, Web은 Command INSERT만 수행
   - 읽기 작업은 쓰기와 동시 수행 가능

3. **단일 서버 운영에 적합**
   - AlphaEngine v2는 단일 계좌/심볼/전략 지원
   - 복잡한 분산 환경 불필요

4. **운영 안정성**
   - 검증된 임베디드 DB
   - Python 표준 라이브러리 지원

## 대안 검토

| 옵션 | 장점 | 단점 |
|------|------|------|
| SQLite + WAL | 단순, 배포 용이 | 원격 접근 불편 |
| PostgreSQL | 동시 쓰기, 원격 | 별도 프로세스 관리 |
| MySQL | 익숙함 | 별도 설치, JSONB 미지원 |

## 결과

- SQLite 3 (WAL 모드) 사용
- SQLAlchemy 2.0 (aiosqlite) ORM 사용
- JSON 필드는 TEXT 타입으로 저장

## 주의사항

- `time`, `count` 등 SQLite 예약어를 컬럼 alias로 사용 금지
- Bot이 Primary Writer, Web Write는 최소화

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-003: Bot/Web 분리 아키텍처

## 컨텍스트

단일 프로세스에서 모든 것을 처리할 수도 있지만,
역할 분리와 독립 배포/재시작이 필요하다.

## 결정

**Bot과 Web을 별도 프로세스로 분리**한다.

```
Bot: WebSocket + REST + 전략 + Executor + Projector
Web: FastAPI + 모니터링 + 설정 + Command 발행
DB:  SQLite WAL (공유)
```

## 이유

1. **역할 명확화**
   - Bot: 실시간 트레이딩에 집중
   - Web: 사용자 인터페이스에 집중

2. **독립 재시작**
   - Web 수정/재시작 시 Bot 중단 없음
   - Bot 재시작 시 Web 영향 없음

3. **리소스 분리**
   - Bot: CPU/메모리 최적화
   - Web: 요청 처리 최적화

4. **보안**
   - Bot: API Key 보유, 내부 네트워크
   - Web: 외부 노출, HTTPS/인증

## Command 전달 방식

Web → Bot 직접 통신 대신 **Command Queue (DB)** 사용:

1. Web이 `command_store`에 INSERT
2. Bot이 주기적으로 NEW 상태 조회
3. Bot이 처리 후 상태 업데이트

이유:
- Bot 재시작 시 Command 유실 없음
- 비동기 처리로 Web 응답 빠름
- 추적 가능 (모든 Command 기록)

## 대안 검토

| 옵션 | 장점 | 단점 |
|------|------|------|
| 단일 프로세스 | 단순 | 재시작 영향, 역할 혼재 |
| Redis Queue | 빠름 | 추가 인프라, 내구성 |
| gRPC | 실시간 | 복잡, Bot 재시작 시 실패 |
| DB Queue | 내구성, 추적 | 폴링 지연 |

## 결과

- Bot: systemd 서비스 (alphaengine-bot.service)
- Web: systemd 서비스 (alphaengine-web.service)
- 통신: command_store 테이블

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-004: 실거래/Testnet 듀얼 모드 지원

## 컨텍스트

실거래 전에 충분한 테스트가 필요하다.
Binance는 Futures Testnet을 제공한다.

## 결정

**설정 파일(secrets.yaml) 기반 듀얼 모드**를 지원한다.

```yaml
# config/secrets.yaml
mode: production  # 또는 testnet
```

## 이유

1. **안전한 테스트**
   - 실제 자금 손실 없이 전략 검증
   - 시스템 안정성 확인

2. **코드 동일성**
   - 같은 코드로 Testnet/Production 실행
   - 환경 차이로 인한 버그 최소화

3. **빠른 전환**
   - 설정 변경만으로 모드 전환
   - 배포 자동화 용이

## 구현

```python
class TradingMode(Enum):
    PRODUCTION = "production"
    TESTNET = "testnet"

# 엔드포인트 매핑
ENDPOINTS = {
    TradingMode.PRODUCTION: {
        "ws": "wss://fstream.binance.com",
        "rest": "https://fapi.binance.com"
    },
    TradingMode.TESTNET: {
        "ws": "wss://stream.binancefuture.com",
        "rest": "https://testnet.binancefuture.com"
    }
}
```

## DB 분리 정책

```
Production: alphaengine_prod.db (SQLite)
Testnet:    alphaengine_test.db (SQLite)
```

이유:
- 데이터 혼재 방지
- 독립적인 이벤트 히스토리
- 실수로 Testnet 데이터를 Production으로 사용 방지

## 결과

- 환경 변수로 모드 선택
- 각 모드별 DB 분리
- 모드는 모든 이벤트의 scope.mode에 기록

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-005: Rate Limit 관리 전략

## 컨텍스트

Binance API는 분당 Rate Limit을 적용한다.
- Request Weight: 분당 1200 (일반), 2400 (VIP)
- Order Count: 분당 300

Polling 및 주문이 많으면 Rate Limit 초과 가능.

## 결정

**응답 헤더 기반 동적 관리**를 채택한다.

## 구현

### 헤더 추적

```python
class RateLimitTracker:
    used_weight_1m: int = 0
    order_count_1m: int = 0
    
    def update(self, headers: dict):
        self.used_weight_1m = int(headers.get("X-MBX-USED-WEIGHT-1m", 0))
        self.order_count_1m = int(headers.get("X-MBX-ORDER-COUNT-1m", 0))
```

### 동적 백오프

| 사용량 | 동작 |
|--------|------|
| < 60% | 정상 |
| 60~80% | 경고 로그 |
| 80~95% | 폴링 간격 증가 |
| > 95% | 요청 중단, 대기 |
| 429 응답 | Retry-After 대기 |

### Hybrid 최적화

- WebSocket으로 대부분 실시간 이벤트 수신
- REST Polling 빈도 감소 (WebSocket 연결 시)
- Rate Limit 부담 최소화

## 결과

- RateLimitTracker 컴포넌트 추가
- 모든 REST 응답에서 헤더 추적
- 동적 폴링 간격 조정

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-006: 운영 환경 (Windows 개발 + Linux 운영)

## 컨텍스트

개발은 Windows에서 하지만, 운영은 Linux에서 한다.
크로스 플랫폼 호환성이 필요하다.

## 결정

**Python + 표준 라이브러리 + 크로스 플랫폼 도구**를 사용한다.

## 핵심 원칙

| 원칙 | 설명 |
|------|------|
| **pathlib 필수** | 모든 경로는 `pathlib.Path` 사용, 문자열 경로 금지 |
| **인코딩 명시** | 파일 I/O 시 `encoding="utf-8"` 필수 |
| **os.path 금지** | `os.path.join()` 대신 `Path / "dir"` 연산자 사용 |
| **플랫폼 분기 최소화** | `sys.platform` 분기는 불가피한 경우만, 주석 필수 |

## 구현

### 1. 경로 처리 (필수 패턴)

```python
from pathlib import Path

# ✅ 프로젝트 루트 정의 (constants.py)
PROJECT_ROOT = Path(__file__).resolve().parent.parent

# ✅ 경로 조합 - / 연산자 사용
config_path = PROJECT_ROOT / "config" / "secrets.yaml"
db_path = PROJECT_ROOT / "data" / "alphaengine.db"

# ✅ 디렉토리 생성 (존재 여부 무관)
db_path.parent.mkdir(parents=True, exist_ok=True)

# ❌ 금지 패턴
path = "config/secrets.yaml"           # 하드코딩 슬래시
path = "config\\secrets.yaml"          # 하드코딩 백슬래시
path = os.path.join("config", "file")  # os.path 사용
```

### 2. 파일 I/O (필수 패턴)

```python
# ✅ pathlib 메서드 사용
content = config_path.read_text(encoding="utf-8")
config_path.write_text(content, encoding="utf-8")

# ✅ open() 사용 시 인코딩 명시
with open(config_path, encoding="utf-8") as f:
    data = yaml.safe_load(f)

# ❌ 금지 패턴 (인코딩 미지정 - Windows/Linux 기본값 다름)
with open(config_path) as f:
    data = f.read()
```

### 3. 환경 변수

```python
# .env 파일 사용 (python-dotenv)
from dotenv import load_dotenv
load_dotenv()
```

### 4. 프로세스 관리

| 환경 | 도구 | 용도 |
|------|------|------|
| Windows (개발) | 직접 실행, 터미널 | 개발, 디버깅, 로컬 테스트 |
| Linux (운영) | systemd 서비스 | 24/7 무중단 운영 |

### 5. systemd 서비스 예시

```ini
# /etc/systemd/system/alphaengine-bot.service
[Unit]
Description=AlphaEngine Bot
After=network.target

[Service]
Type=simple
User=alphaengine
WorkingDirectory=/opt/alphaengine
Environment=AE_MODE=production
ExecStart=/opt/alphaengine/venv/bin/python -m bot
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

## 코드 리뷰 체크리스트

PR 리뷰 시 아래 항목 확인:

- [ ] 모든 경로가 `pathlib.Path` 타입인가?
- [ ] 문자열로 하드코딩된 경로(`"data/file.db"`)가 없는가?
- [ ] `os.path` 사용이 없는가?
- [ ] 파일 I/O에 `encoding="utf-8"` 명시했는가?
- [ ] `sys.platform` 분기가 있다면 주석으로 이유 설명했는가?

## 테스트 전략

| 테스트 유형 | 실행 환경 | 내용 |
|-------------|-----------|------|
| 단위 테스트 | Windows + Linux | pytest, 경로 타입 검증 포함 |
| 통합 테스트 | Windows + Linux | Mock 기반, SQLite |
| E2E 테스트 | Linux (CI) | Testnet 실제 호출 |
| 운영 테스트 | Linux VM/Cloud | systemd, 24시간 안정성 |

### CI/CD 매트릭스 (필수)

```yaml
# .github/workflows/test.yml
jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        python-version: ['3.11', '3.12']
    runs-on: ${{ matrix.os }}
```

## 강제 규칙 (Cursor Rules 연동)

`.cursor/rules/python-general.mdc`에 크로스 플랫폼 규칙이 정의되어 있으며, 
모든 `**/*.py` 파일 편집 시 자동 적용됨:

- `pathlib.Path` 사용 강제
- `os.path` 사용 금지
- 인코딩 명시 강제

## 배포 문서화 (docs/deploy/)

배포 및 운영 관련 결정 사항은 `docs/deploy/` 디렉토리에 문서화한다.

### 필수 문서

| 문서 | 내용 |
|------|------|
| `README.md` | 배포 개요 및 퀵 가이드 |
| `setup.md` | 서버 초기 설정 (의존성, 사용자, 디렉토리) |
| `systemd.md` | systemd 서비스 설정 (Bot, Web) |
| `nginx.md` | nginx 리버스 프록시 설정 (필요시) |
| `backup.md` | DB 백업/복구 절차 |
| `monitoring.md` | 로그, 모니터링, 알림 설정 |
| `troubleshooting.md` | 운영 중 문제 해결 가이드 |

### 문서 작성 원칙

1. **즉시 문서화**: 배포/운영 관련 결정 시 바로 문서에 반영
2. **복사-붙여넣기**: 모든 명령어는 그대로 복사해서 실행 가능하게 작성
3. **전체 설정**: 설정 파일은 부분이 아닌 전체 내용 포함
4. **문제 기록**: 운영 중 발생한 문제와 해결책은 즉시 `troubleshooting.md`에 추가

### 예시 구조

```
docs/deploy/
├── README.md           # 배포 개요, 필수 환경, 퀵 스타트
├── setup.md            # apt install, useradd, mkdir, venv 등
├── systemd.md          # alphaengine-bot.service, alphaengine-web.service
├── nginx.md            # 리버스 프록시 설정 (HTTPS 포함)
├── backup.md           # SQLite 백업 스크립트, cron 설정
├── monitoring.md       # journalctl, logrotate, 외부 알림
└── troubleshooting.md  # 문제 상황별 해결책
```

## 결과

- 크로스 플랫폼 코드 작성
- Windows에서 개발/디버깅
- Linux에서 CI/CD 및 운영
- **Cursor Rules로 자동 검증**
- **배포/운영 지식이 문서로 축적**

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-007: Web Framework 선택 (FastAPI)

## 컨텍스트

Web 모니터링 및 설정 변경을 위한 프레임워크가 필요하다.

## 결정

**FastAPI**를 채택한다.

## 이유

1. **비동기 지원**
   - asyncio 네이티브
   - PostgreSQL async 연동

2. **자동 문서화**
   - OpenAPI (Swagger) 자동 생성
   - API 테스트 용이

3. **타입 힌트**
   - Pydantic 기반 검증
   - IDE 자동완성 지원

4. **성능**
   - uvicorn + asyncio로 고성능
   - SQLite aiosqlite와 호환

## 대안 검토

| 옵션 | 장점 | 단점 |
|------|------|------|
| Flask | 단순, 익숙함 | 동기식, 문서화 수동 |
| Django | 풀스택 | 과도한 기능, 무거움 |
| FastAPI | 비동기, 문서화, 타입 | 학습 곡선 |

## 구조

```
web/
├── app.py          # FastAPI 앱
├── routes/
│   ├── dashboard.py   # GET /api/dashboard
│   ├── events.py      # GET /api/events
│   ├── commands.py    # GET/POST /api/commands
│   └── config.py      # GET/PUT /api/config
└── models/
    └── schemas.py     # Pydantic 스키마
```

## 결과

- FastAPI + uvicorn 사용
- OpenAPI 문서 자동 생성
- Pydantic 스키마로 요청/응답 검증

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-008: EngineState RUNNING 유지 정책

## 컨텍스트

v1에서 논의된 내용: 장애 상황에서 EngineState를 어떻게 관리할 것인가?

## 결정

**EngineState는 가능한 RUNNING을 유지**한다.

## 이유

1. **장애 상황에서도 복구 가능해야 한다**
   - 자동 복구 시도
   - SAFE 모드로 전환하되 완전 정지는 피함

2. **수동 개입 최소화**
   - 새벽 장애 시 자동 복구
   - 관리자 개입 없이 정상화

3. **상태 전이 명확화**
   - RUNNING → SAFE: 리스크 위반 시
   - SAFE → RUNNING: 수동 또는 자동 (정책에 따라)
   - PAUSED: 명시적 사용자 요청만

## 결과

- 장애 시 SAFE 모드로 전환 (신규 진입 차단)
- 리스크 정상화 시 RUNNING 복귀 가능
- PAUSED는 사용자 명시적 요청만

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-009: 설정 관리 방식 (파일 + DB + 하드코딩)

## 컨텍스트

AlphaEngine v2에서 설정을 어떻게 관리할 것인가?
- 환경변수 22개는 과도하게 많고 관리가 불편하다
- 보안이 필요한 항목과 런타임 변경이 필요한 항목이 다르다

## 결정

**3단계 설정 관리**를 채택한다.

1. **secrets.yaml** (git ignore): 보안 정보 (API Key 등)
2. **DB config_store**: 런타임 변경 가능한 설정
3. **하드코딩**: 고정 상수 (거래소 URL 등)

## 구현

### 1. secrets.yaml (보안 정보)

```yaml
# config/secrets.yaml (git ignore 필수)
mode: testnet  # production | testnet

production:
  api_key: "your_production_api_key"
  api_secret: "your_production_api_secret"

testnet:
  api_key: "your_testnet_api_key"
  api_secret: "your_testnet_api_secret"

web:
  secret_key: "your_jwt_secret_key"
```

**파일 권한**: `chmod 600 secrets.yaml` (소유자만 읽기/쓰기)

### 2. DB config_store (런타임 설정)

```sql
CREATE TABLE config_store (
  key           TEXT PRIMARY KEY,
  value_json    TEXT NOT NULL,
  version       INTEGER NOT NULL DEFAULT 1,
  updated_at    TEXT NOT NULL DEFAULT (datetime('now')),
  updated_by    TEXT NOT NULL DEFAULT 'system'
);
```

**저장 내용**:
```json
{
  "trading": {
    "symbol": "XRPUSDT",
    "account_id": "main"
  },
  "strategy": {
    "name": "sma_cross",
    "timeframe": "5m",
    "params": {"fast": 10, "slow": 20}
  },
  "risk": {
    "max_risk_per_trade": 0.02,
    "daily_loss_limit": 0.05
  },
  "engine": {
    "poll_interval_sec": 30
  },
  "logging": {
    "level": "INFO"
  }
}
```

### 3. 하드코딩 (고정 상수)

```python
# core/constants.py

class BinanceEndpoints:
    """Binance API 엔드포인트 (변경될 일 없음)"""
    
    # Production
    PROD_REST_URL = "https://fapi.binance.com"
    PROD_WS_URL = "wss://fstream.binance.com"
    
    # Testnet
    TEST_REST_URL = "https://testnet.binancefuture.com"
    TEST_WS_URL = "wss://stream.binancefuture.com"

class Defaults:
    """기본값 상수"""
    EXCHANGE = "BINANCE"
    VENUE = "FUTURES"
    WEB_HOST = "127.0.0.1"
    WEB_PORT = 8000
```

## 설정 로딩 흐름

```
1. Bot 시작
   ↓
2. secrets.yaml 로드 (mode, API Key 등)
   ↓
3. mode에 따라 DB 파일 선택 (prod.db / test.db)
   ↓
4. DB config_store 조회
   - 없으면: 기본값으로 INSERT
   - 있으면: 로드
   ↓
5. 하드코딩 상수와 합쳐서 최종 Config 생성
   ↓
6. Bot 실행
```

## 설정 분류 정리

| 분류 | 저장 위치 | 예시 |
|------|----------|------|
| **보안 정보** | secrets.yaml | api_key, api_secret, jwt_secret |
| **모드 선택** | secrets.yaml | mode (production/testnet) |
| **거래 설정** | DB config_store | symbol, account_id |
| **전략 설정** | DB config_store | strategy_name, params, timeframe |
| **리스크 설정** | DB config_store | max_risk, daily_loss_limit |
| **엔진 설정** | DB config_store | poll_interval |
| **로깅 설정** | DB config_store | log_level |
| **고정 URL** | 하드코딩 | Binance REST/WS URL |
| **기본값** | 하드코딩 | exchange, venue, web_host, web_port |

## 이유

1. **보안 분리**
   - API Key는 파일로 관리 (DB 유출 시 안전)
   - 파일 권한으로 접근 제어

2. **런타임 유연성**
   - 전략, 리스크 설정 등은 Web에서 실시간 변경
   - 서버 재시작 없이 적용

3. **단순화**
   - 환경변수 22개 → secrets.yaml 1개 + DB
   - 서버 설정 의존성 제거

4. **하드코딩 적합성**
   - Binance URL은 변경될 일이 거의 없음
   - 코드에서 상수로 관리하는 것이 명확

## 결과

- secrets.yaml 파일 (git ignore)
- config_store 테이블
- core/constants.py 모듈
- .env 파일 제거 (불필요)

## 상태

**승인됨**

------------------------------------------------------------------------

# ADR-010: 타임존 전략 (내부 UTC, 표시 KST)

## 컨텍스트

시스템에서 시간을 어떻게 처리할 것인가?
- 개발자/운영자는 KST(한국 시간)로 로그를 보고 싶다
- Binance API는 UTC 밀리초 타임스탬프를 사용한다
- 서버 시스템 시간이 UTC 또는 KST로 설정될 수 있다

## 결정

**내부 저장: UTC | 외부 표시: KST** 원칙을 채택한다.

```
저장/처리: datetime.now(timezone.utc)  → UTC
로그/UI:   format_kst(event.ts)        → KST 변환
```

## 이유

1. **Binance API 호환성**
   - 모든 타임스탬프가 UTC 밀리초로 반환됨
   - 변환 로직 없이 직접 비교 가능

2. **서버 시간 독립성**
   - `datetime.now(timezone.utc)` 사용 시 서버 시스템 시간 설정과 무관
   - Windows(개발), Linux(운영) 모두 동일 동작

3. **이벤트 정렬 정확성**
   - 시간순 정렬 시 타임존 혼란 방지
   - dedup_key 일관성 보장

4. **Reconciler 정합성**
   - WebSocket + REST 이벤트 비교 시 동일 기준 필요
   - DST(서머타임) 문제 회피 (한국은 없지만 원칙적으로)

## 구현

### 필수 패턴

```python
from datetime import datetime, timezone

# ✅ 모든 datetime 생성 시 UTC 명시
now = datetime.now(timezone.utc)

# ✅ 타임스탬프 변환 시 UTC 명시
dt = datetime.fromtimestamp(ts_ms / 1000, tz=timezone.utc)

# ❌ 금지 (서버 시간 의존)
now = datetime.now()
now = datetime.utcnow()  # deprecated
```

### KST 변환 유틸리티

```python
# core/utils/timezone.py
from datetime import datetime, timezone, timedelta

KST = timezone(timedelta(hours=9))

def format_kst(dt: datetime, fmt: str = "%Y-%m-%d %H:%M:%S") -> str:
    """UTC datetime을 KST 문자열로 포맷"""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(KST).strftime(fmt)
```

### 사용 계층

| 계층 | 저장/처리 | 표시 |
|------|----------|------|
| Event/Command | UTC | - |
| EventStore (DB) | UTC (ISO 8601) | - |
| Binance API 통신 | UTC (밀리초) | - |
| 로그 출력 | - | KST |
| Web API 응답 | UTC | KST (추가 필드) |
| 콘솔/터미널 출력 | - | KST |

## 금지 패턴

```python
# ❌ datetime.now() - tzinfo 없음, 서버 설정 의존
now = datetime.now()

# ❌ datetime.utcnow() - UTC지만 tzinfo 없음 (Python 3.12+ deprecated)
now = datetime.utcnow()

# ❌ fromtimestamp() 타임존 미지정
dt = datetime.fromtimestamp(ts_ms / 1000)

# ❌ KST와 UTC 혼용 비교
if kst_datetime > utc_datetime:
    ...
```

## 강제 규칙

`.cursor/rules/timezone.mdc`에 타임존 규칙이 정의되어 있으며,
모든 `**/*.py` 파일 편집 시 자동 적용됨:

- `datetime.now(timezone.utc)` 사용 강제
- `datetime.now()`, `datetime.utcnow()` 금지
- 로그 출력 시 KST 변환 권장

## 결과

- `core/utils/timezone.py` 유틸리티 모듈 추가
- 모든 Event/Command의 ts 필드는 UTC
- 로그/UI 출력 시 KST로 변환
- 서버 시스템 시간 설정과 무관하게 동작

## 상태

**승인됨**

------------------------------------------------------------------------

문서 종료

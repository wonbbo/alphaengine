# AlphaEngine v2 TRD --- WebSocket Specification

생성일: 2026-02-20

본 문서는 AlphaEngine v2의 WebSocket 연동 사양을 TRD 수준으로 고정한다.

------------------------------------------------------------------------

# 1. 개요

AlphaEngine v2는 **Binance Futures User Data Stream**을 사용하여 실시간 계좌/주문/포지션 변경을 수신한다.

## 목적

- 체결 감지 지연 최소화 (50~100ms)
- Rate Limit 부담 감소
- REST Polling의 백업으로 정합성 유지

## 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                    Hybrid Data Flow                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Binance                                                         │
│  ┌──────────────────┐     ┌──────────────────┐                 │
│  │ User Data Stream │     │    REST API      │                 │
│  │ (WebSocket)      │     │                  │                 │
│  └────────┬─────────┘     └────────┬─────────┘                 │
│           │                        │                            │
│           │ 50~100ms              │ 30초~1분                    │
│           ↓                        ↓                            │
│  ┌────────────────────────────────────────────────────────────┐│
│  │                    Bot Process                              ││
│  │                                                             ││
│  │  ┌──────────────────┐    ┌──────────────────┐             ││
│  │  │ WebSocket        │    │ REST             │             ││
│  │  │ Listener         │    │ Reconciler       │             ││
│  │  └────────┬─────────┘    └────────┬─────────┘             ││
│  │           │                        │                        ││
│  │           └───────────┬───────────┘                        ││
│  │                       ↓                                     ││
│  │              ┌──────────────────┐                          ││
│  │              │   Event Merger   │ dedup_key로 병합          ││
│  │              └────────┬─────────┘                          ││
│  │                       ↓                                     ││
│  │              ┌──────────────────┐                          ││
│  │              │   Event Store    │                          ││
│  │              └──────────────────┘                          ││
│  │                                                             ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

------------------------------------------------------------------------

# 2. Binance User Data Stream

## 2.1 엔드포인트

| 모드 | WebSocket URL | REST (listenKey) |
|------|---------------|------------------|
| Production | `wss://fstream.binance.com/ws/<listenKey>` | `https://fapi.binance.com` |
| Testnet | `wss://stream.binancefuture.com/ws/<listenKey>` | `https://testnet.binancefuture.com` |

## 2.2 listenKey 관리

### 생성

```http
POST /fapi/v1/listenKey
X-MBX-APIKEY: <API_KEY>
```

응답:
```json
{"listenKey": "pqia91ma19fsdfjk34asdj..."}
```

### 연장 (30분마다)

```http
PUT /fapi/v1/listenKey
X-MBX-APIKEY: <API_KEY>
```

### 삭제 (선택)

```http
DELETE /fapi/v1/listenKey
X-MBX-APIKEY: <API_KEY>
```

### 만료 정책

- listenKey 유효 기간: 60분
- 30분마다 연장 필수
- 연장 실패 시 재생성

------------------------------------------------------------------------

# 3. 메시지 타입

## 3.1 ACCOUNT_UPDATE

계좌 잔고/포지션 변경 시 발생.

```json
{
  "e": "ACCOUNT_UPDATE",
  "T": 1564745798939,
  "E": 1564745798943,
  "a": {
    "m": "ORDER",
    "B": [
      {
        "a": "USDT",
        "wb": "122624.12345678",
        "cw": "100.12345678",
        "bc": "50.12345678"
      }
    ],
    "P": [
      {
        "s": "XRPUSDT",
        "pa": "100",
        "ep": "0.5123",
        "cr": "200",
        "up": "10.5",
        "mt": "cross",
        "iw": "0.00000000",
        "ps": "LONG"
      }
    ]
  }
}
```

### 필드 설명

| 필드 | 설명 |
|------|------|
| `e` | 이벤트 타입 |
| `T` | 트랜잭션 시간 (ms) |
| `E` | 이벤트 시간 (ms) |
| `a.m` | 이벤트 사유 (ORDER, FUNDING_FEE, etc.) |
| `a.B` | 잔고 변경 목록 |
| `a.B[].a` | 자산 |
| `a.B[].wb` | 지갑 잔고 |
| `a.B[].cw` | Cross 지갑 잔고 |
| `a.B[].bc` | 잔고 변경량 |
| `a.P` | 포지션 변경 목록 |
| `a.P[].s` | 심볼 |
| `a.P[].pa` | 포지션 수량 |
| `a.P[].ep` | 진입가 |
| `a.P[].up` | 미실현 손익 |
| `a.P[].ps` | 포지션 방향 (LONG/SHORT/BOTH) |

### 매핑

- `a.B` 변경 → `BalanceChanged` 이벤트
- `a.P` 변경 → `PositionChanged` 이벤트

------------------------------------------------------------------------

## 3.2 ORDER_TRADE_UPDATE

주문 상태 변경 또는 체결 시 발생.

```json
{
  "e": "ORDER_TRADE_UPDATE",
  "T": 1568879465651,
  "E": 1568879465653,
  "o": {
    "s": "XRPUSDT",
    "c": "ae-550e8400-e29b-41d4-a716-446655440000",
    "S": "BUY",
    "o": "MARKET",
    "f": "GTC",
    "q": "100",
    "p": "0",
    "ap": "0.5123",
    "sp": "0",
    "x": "TRADE",
    "X": "FILLED",
    "i": 8886774,
    "l": "100",
    "z": "100",
    "L": "0.5123",
    "n": "0.05123",
    "N": "USDT",
    "T": 1568879465651,
    "t": 1234567890,
    "b": "0",
    "a": "0",
    "m": false,
    "R": false,
    "wt": "CONTRACT_PRICE",
    "ot": "MARKET",
    "ps": "LONG",
    "cp": false,
    "rp": "0"
  }
}
```

### 필드 설명

| 필드 | 설명 |
|------|------|
| `o.s` | 심볼 |
| `o.c` | client_order_id |
| `o.S` | 방향 (BUY/SELL) |
| `o.o` | 주문 타입 |
| `o.X` | 주문 상태 (NEW, PARTIALLY_FILLED, FILLED, CANCELLED, etc.) |
| `o.i` | exchange_order_id |
| `o.l` | 마지막 체결 수량 |
| `o.L` | 마지막 체결 가격 |
| `o.z` | 누적 체결 수량 |
| `o.t` | trade_id |
| `o.n` | 수수료 |
| `o.N` | 수수료 자산 |
| `o.rp` | 실현 손익 |

### 매핑

- `o.x == "TRADE"` → `TradeExecuted` 이벤트
- `o.X` 변경 → `OrderUpdated` 이벤트
- `o.X == "NEW"` (신규) → `OrderPlaced` 이벤트
- `o.X == "CANCELLED"` → `OrderCancelled` 이벤트
- `o.X == "REJECTED"` → `OrderRejected` 이벤트

------------------------------------------------------------------------

## 3.3 MARGIN_CALL (선택)

마진 콜 발생 시.

```json
{
  "e": "MARGIN_CALL",
  "E": 1587727187525,
  "cw": "3.16812045",
  "p": [
    {
      "s": "XRPUSDT",
      "ps": "LONG",
      "pa": "100",
      "mt": "cross",
      "iw": "0",
      "mp": "0.5123",
      "up": "-100.5",
      "mm": "10"
    }
  ]
}
```

→ `RiskGuardRejected` 또는 `EngineModeChanged` (SAFE) 이벤트

------------------------------------------------------------------------

# 4. WebSocket Listener 구현

## 4.1 클래스 구조

```python
from enum import Enum
from typing import Callable, Awaitable
import asyncio
import websockets
import json

class WebSocketState(Enum):
    DISCONNECTED = "DISCONNECTED"
    CONNECTING = "CONNECTING"
    CONNECTED = "CONNECTED"
    RECONNECTING = "RECONNECTING"

class BinanceWebSocketListener:
    """Binance Futures User Data Stream 리스너"""
    
    def __init__(
        self,
        ws_url: str,
        rest_client: "BinanceRestClient",
        on_message: Callable[[dict], Awaitable[None]],
        on_state_change: Callable[[WebSocketState], Awaitable[None]],
    ):
        self.ws_url = ws_url
        self.rest_client = rest_client
        self.on_message = on_message
        self.on_state_change = on_state_change
        
        self.state = WebSocketState.DISCONNECTED
        self.listen_key: str | None = None
        self.ws: websockets.WebSocketClientProtocol | None = None
        self._keepalive_task: asyncio.Task | None = None
        self._receive_task: asyncio.Task | None = None
    
    async def start(self) -> None:
        """WebSocket 연결 시작"""
        await self._connect()
    
    async def stop(self) -> None:
        """WebSocket 연결 종료"""
        await self._disconnect()
    
    async def _connect(self) -> None:
        """연결 수행"""
        try:
            await self._set_state(WebSocketState.CONNECTING)
            
            # listenKey 생성
            self.listen_key = await self.rest_client.create_listen_key()
            
            # WebSocket 연결
            url = f"{self.ws_url}/{self.listen_key}"
            self.ws = await websockets.connect(url, ping_interval=30)
            
            await self._set_state(WebSocketState.CONNECTED)
            
            # keepalive 태스크 시작
            self._keepalive_task = asyncio.create_task(self._keepalive_loop())
            
            # 메시지 수신 루프
            self._receive_task = asyncio.create_task(self._receive_loop())
            
        except Exception as e:
            await self._handle_error(e)
    
    async def _receive_loop(self) -> None:
        """메시지 수신 루프"""
        try:
            async for message in self.ws:
                data = json.loads(message)
                await self.on_message(data)
        except websockets.ConnectionClosed:
            await self._handle_disconnect()
        except Exception as e:
            await self._handle_error(e)
    
    async def _keepalive_loop(self) -> None:
        """listenKey 연장 루프 (30분마다)"""
        while self.state == WebSocketState.CONNECTED:
            await asyncio.sleep(30 * 60)  # 30분
            try:
                await self.rest_client.extend_listen_key()
            except Exception as e:
                # listenKey 연장 실패 → 재연결
                await self._handle_error(e)
                break
    
    async def _handle_disconnect(self) -> None:
        """연결 끊김 처리"""
        await self._set_state(WebSocketState.RECONNECTING)
        await self._reconnect_with_backoff()
    
    async def _reconnect_with_backoff(self) -> None:
        """지수 백오프로 재연결"""
        delay = 1
        max_delay = 30
        
        while self.state == WebSocketState.RECONNECTING:
            try:
                await self._connect()
                return
            except Exception:
                await asyncio.sleep(delay)
                delay = min(delay * 2, max_delay)
    
    async def _set_state(self, new_state: WebSocketState) -> None:
        """상태 변경 및 알림"""
        old_state = self.state
        self.state = new_state
        if old_state != new_state:
            await self.on_state_change(new_state)
```

------------------------------------------------------------------------

## 4.2 메시지 처리

```python
class WebSocketMessageHandler:
    """WebSocket 메시지 → Event 변환"""
    
    def __init__(self, event_store: "EventStore", scope: "Scope"):
        self.event_store = event_store
        self.scope = scope
    
    async def handle(self, message: dict) -> None:
        """메시지 타입에 따라 이벤트 생성"""
        event_type = message.get("e")
        
        if event_type == "ACCOUNT_UPDATE":
            await self._handle_account_update(message)
        elif event_type == "ORDER_TRADE_UPDATE":
            await self._handle_order_trade_update(message)
        elif event_type == "MARGIN_CALL":
            await self._handle_margin_call(message)
    
    async def _handle_account_update(self, msg: dict) -> None:
        """ACCOUNT_UPDATE 처리"""
        data = msg["a"]
        tx_time = msg["T"]
        
        # 잔고 변경
        for b in data.get("B", []):
            event = self._create_balance_changed_event(b, tx_time)
            await self.event_store.append(event)
        
        # 포지션 변경
        for p in data.get("P", []):
            if p["s"] == self.scope.symbol:
                event = self._create_position_changed_event(p, tx_time)
                await self.event_store.append(event)
    
    async def _handle_order_trade_update(self, msg: dict) -> None:
        """ORDER_TRADE_UPDATE 처리"""
        o = msg["o"]
        
        if o["s"] != self.scope.symbol:
            return
        
        # 체결 발생
        if o["x"] == "TRADE" and float(o["l"]) > 0:
            event = self._create_trade_executed_event(o)
            await self.event_store.append(event)
        
        # 주문 상태 변경
        event = self._create_order_updated_event(o)
        await self.event_store.append(event)
    
    def _create_trade_executed_event(self, o: dict) -> "Event":
        """TradeExecuted 이벤트 생성"""
        trade_id = str(o["t"])
        dedup_key = f"{self.scope.exchange}:{self.scope.venue}:{self.scope.symbol}:trade:{trade_id}"
        
        return Event.new(
            event_type="TradeExecuted",
            source="WEBSOCKET",
            entity_kind="TRADE",
            entity_id=trade_id,
            scope=self.scope,
            dedup_key=dedup_key,
            payload={
                "exchange_trade_id": trade_id,
                "exchange_order_id": str(o["i"]),
                "client_order_id": o["c"],
                "side": o["S"],
                "qty": o["l"],
                "price": o["L"],
                "commission": o["n"],
                "commission_asset": o["N"],
                "realized_pnl": o["rp"],
                "trade_time": o["T"],
            }
        )
```

------------------------------------------------------------------------

# 5. Hybrid 병합 규칙

## 5.1 Event Store Append

```python
async def append(self, event: Event) -> bool:
    """이벤트 저장 (dedup_key로 중복 제거)"""
    try:
        await self.db.execute(
            """
            INSERT INTO event_store (...)
            VALUES (...)
            ON CONFLICT (dedup_key) DO NOTHING
            """
        )
        return True
    except Exception:
        # 중복 또는 에러
        return False
```

## 5.2 WebSocket 우선, REST 보완

```
시간 ─────────────────────────────────────────────────→
      │                                               │
      │  WebSocket                                    │
      │  ┌───┐ ┌───┐     (연결 끊김)     ┌───┐       │
      │  │ A │ │ B │         X          │ E │       │
      │  └───┘ └───┘                    └───┘       │
      │                                               │
      │  REST (30초 간격)                             │
      │        ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐       │
      │        │ A │ │ B │ │ C │ │ D │ │ E │       │
      │        └───┘ └───┘ └───┘ └───┘ └───┘       │
      │        (무시) (무시) (저장) (저장) (무시)      │
      │                                               │
```

- A, B: WebSocket에서 먼저 수신 → REST에서 무시 (dedup)
- C, D: WebSocket 끊김 중 발생 → REST에서 수집
- E: 재연결 후 WebSocket에서 먼저 수신 → REST에서 무시

------------------------------------------------------------------------

# 6. 상태 변경 처리

## 6.1 WebSocketState → Event

```python
async def on_state_change(self, new_state: WebSocketState) -> None:
    """WebSocket 상태 변경 시 이벤트 생성"""
    event_map = {
        WebSocketState.CONNECTED: "WebSocketConnected",
        WebSocketState.DISCONNECTED: "WebSocketDisconnected",
        WebSocketState.RECONNECTING: "WebSocketDisconnected",
    }
    
    event_type = event_map.get(new_state)
    if event_type:
        event = Event.new(
            event_type=event_type,
            source="BOT",
            entity_kind="ENGINE",
            entity_id="websocket",
            scope=self.scope,
            dedup_key=f"{self.scope.exchange}:ws:{event_type}:{int(time.time() * 1000)}",
            payload={"state": new_state.value}
        )
        await self.event_store.append(event)
```

## 6.2 연결 끊김 시 REST 폴링 강화

```python
class HybridReconciler:
    """Hybrid 방식 Reconciler"""
    
    def __init__(self, ws_listener: BinanceWebSocketListener, ...):
        self.ws_listener = ws_listener
        self.normal_interval = 30  # 초
        self.fallback_interval = 5  # 초 (WebSocket 끊김 시)
    
    @property
    def poll_interval(self) -> int:
        """현재 폴링 간격"""
        if self.ws_listener.state == WebSocketState.CONNECTED:
            return self.normal_interval
        else:
            return self.fallback_interval
```

------------------------------------------------------------------------

# 7. 에러 처리

## 7.1 연결 에러

| 에러 | 처리 |
|------|------|
| Connection refused | 지수 백오프 재연결 |
| Connection reset | 즉시 재연결 시도 |
| Invalid listenKey | listenKey 재생성 후 재연결 |
| Rate limited | 대기 후 재연결 |

## 7.2 메시지 파싱 에러

```python
async def handle(self, message: dict) -> None:
    try:
        # 메시지 처리
        ...
    except KeyError as e:
        # 필수 필드 누락 - 로그 후 무시
        logger.warning(f"Invalid message format: {e}")
    except Exception as e:
        # 예상치 못한 에러 - 로그 후 무시
        logger.error(f"Message handling error: {e}")
```

------------------------------------------------------------------------

# 8. 검증 체크리스트

- [ ] listenKey 자동 갱신 (30분마다)
- [ ] 연결 끊김 시 자동 재연결
- [ ] 재연결 시 지수 백오프 적용
- [ ] WebSocketState 이벤트 기록
- [ ] ACCOUNT_UPDATE → BalanceChanged, PositionChanged
- [ ] ORDER_TRADE_UPDATE → TradeExecuted, OrderUpdated
- [ ] dedup_key로 중복 이벤트 방지
- [ ] WebSocket 끊김 시 REST 폴링 강화
- [ ] Testnet/Production 엔드포인트 전환

------------------------------------------------------------------------

문서 종료

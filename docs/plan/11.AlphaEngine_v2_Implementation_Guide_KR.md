# AlphaEngine v2 --- Implementation Guide

생성일: 2026-02-20

본 문서는 AlphaEngine v2 구현을 위한 종합 가이드를 제공한다.

------------------------------------------------------------------------

# 1. 프로젝트 구조

```
alphaengine-v2/
│
├── bot/                        # Bot 프로세스
│   ├── __init__.py
│   ├── __main__.py            # 진입점: python -m bot
│   ├── bootstrap.py           # 메인 루프
│   ├── config.py              # Bot 설정
│   │
│   ├── websocket/             # WebSocket 모듈
│   │   ├── __init__.py
│   │   ├── listener.py        # WebSocketListener
│   │   ├── handler.py         # 메시지 핸들러
│   │   └── state.py           # WebSocketState
│   │
│   ├── reconciler/            # Reconciler 모듈
│   │   ├── __init__.py
│   │   ├── reconciler.py      # HybridReconciler
│   │   ├── drift.py           # DriftDetector
│   │   └── resolver.py        # DriftResolver
│   │
│   ├── executor/              # Executor 모듈
│   │   ├── __init__.py
│   │   ├── executor.py        # CommandExecutor
│   │   ├── order.py           # 주문 실행
│   │   └── timeout.py         # 타임아웃 처리
│   │
│   ├── projector/             # Projector 모듈
│   │   ├── __init__.py
│   │   ├── projector.py       # EventProjector
│   │   └── handlers/          # 이벤트 타입별 핸들러
│   │
│   ├── strategy/              # Strategy Runner 모듈
│   │   ├── __init__.py
│   │   ├── runner.py          # StrategyRunner
│   │   ├── emitter.py         # CommandEmitter 구현
│   │   └── loader.py          # 전략 로더
│   │
│   └── command/               # Command 처리
│       ├── __init__.py
│       ├── claimer.py         # CommandClaimer
│       └── processor.py       # CommandProcessor
│
├── web/                       # Web 프로세스
│   ├── __init__.py
│   ├── __main__.py           # 진입점
│   ├── app.py                # FastAPI 앱
│   ├── config.py             # Web 설정
│   ├── dependencies.py       # 의존성 주입
│   │
│   ├── routes/               # API 라우트
│   │   ├── __init__.py
│   │   ├── dashboard.py      # GET /api/dashboard
│   │   ├── events.py         # GET /api/events
│   │   ├── commands.py       # GET/POST /api/commands
│   │   ├── config.py         # GET/PUT /api/config
│   │   ├── health.py         # GET /health
│   │   └── auth.py           # 인증 관련
│   │
│   ├── models/               # Pydantic 스키마
│   │   ├── __init__.py
│   │   ├── requests.py       # 요청 스키마
│   │   └── responses.py      # 응답 스키마
│   │
│   └── services/             # 비즈니스 로직
│       ├── __init__.py
│       ├── dashboard_service.py
│       ├── event_service.py
│       ├── command_service.py
│       └── config_service.py
│
├── core/                     # 공통 코어
│   ├── __init__.py
│   │
│   ├── domain/               # 도메인 모델
│   │   ├── __init__.py
│   │   ├── events.py         # Event 클래스
│   │   ├── commands.py       # Command 클래스
│   │   ├── types.py          # Scope, Actor 등
│   │   └── enums.py          # Enum 정의
│   │
│   ├── storage/              # 저장소 인터페이스
│   │   ├── __init__.py
│   │   ├── event_store.py    # EventStore
│   │   ├── command_store.py  # CommandStore
│   │   └── config_store.py   # ConfigStore
│   │
│   └── config/               # 설정 관리
│       ├── __init__.py
│       ├── settings.py       # 전역 설정
│       └── mode.py           # TradingMode
│
├── adapters/                 # 외부 연동
│   ├── __init__.py
│   │
│   ├── binance/              # Binance 어댑터
│   │   ├── __init__.py
│   │   ├── ws_client.py      # WebSocket 클라이언트
│   │   ├── rest_client.py    # REST 클라이언트
│   │   ├── rate_limiter.py   # Rate Limit 관리
│   │   └── models.py         # DTO
│   │
│   └── db/                   # PostgreSQL 어댑터
│       ├── __init__.py
│       ├── session.py        # 세션 관리
│       ├── models.py         # SQLAlchemy 모델
│       └── repositories.py   # Repository 패턴
│
├── strategies/               # 전략 플러그인
│   ├── __init__.py
│   ├── base.py               # Strategy 기본 클래스
│   ├── sma_cross.py          # SMA 크로스 예제
│   └── template.py           # 템플릿
│
├── migrations/               # Alembic 마이그레이션
│   ├── env.py
│   ├── alembic.ini
│   └── versions/
│
├── deploy/                   # 배포 설정
│   ├── systemd/
│   │   ├── alphaengine-bot.service
│   │   └── alphaengine-web.service
│   ├── nginx/
│   │   └── alphaengine.conf
│   └── docker/
│       ├── Dockerfile.bot
│       ├── Dockerfile.web
│       └── docker-compose.yml
│
├── tests/                    # 테스트
│   ├── __init__.py
│   ├── conftest.py           # pytest 설정
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── scripts/                  # 유틸리티 스크립트
│   ├── setup_db.py
│   ├── migrate.py
│   └── health_check.py
│
├── pyproject.toml            # 의존성 관리
├── .env.example              # 환경 변수 예시
├── .env.production           # Production 환경 (git ignore)
├── .env.testnet              # Testnet 환경 (git ignore)
└── README.md
```

------------------------------------------------------------------------

# 2. 의존성

## 2.1 pyproject.toml

```toml
[project]
name = "alphaengine-v2"
version = "2.0.0"
description = "Hybrid Trading Engine with Bot/Web Architecture"
requires-python = ">=3.11"

dependencies = [
    # Core
    "pydantic>=2.0",
    "pydantic-settings>=2.0",
    
    # Async
    "asyncio>=3.4",
    "aiohttp>=3.9",
    
    # Database
    "sqlalchemy[asyncio]>=2.0",
    "asyncpg>=0.29",         # PostgreSQL async driver
    "alembic>=1.13",
    
    # WebSocket
    "websockets>=12.0",
    
    # HTTP Client
    "httpx>=0.26",
    
    # Web Framework
    "fastapi>=0.109",
    "uvicorn[standard]>=0.27",
    
    # Auth
    "python-jose[cryptography]>=3.3",
    "passlib[bcrypt]>=1.7",
    
    # Utilities
    "python-dotenv>=1.0",
    "structlog>=24.1",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0",
    "pytest-asyncio>=0.23",
    "pytest-cov>=4.1",
    "ruff>=0.1",
    "mypy>=1.8",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.ruff]
line-length = 100
target-version = "py311"

[tool.mypy]
python_version = "3.11"
strict = true
```

------------------------------------------------------------------------

# 3. 핵심 구현

## 3.1 Event 클래스

```python
# core/domain/events.py

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any
from uuid import uuid4


@dataclass
class Scope:
    """거래 범위"""
    exchange: str
    venue: str
    account_id: str
    symbol: str | None
    mode: str


@dataclass
class Event:
    """이벤트"""
    event_id: str
    event_type: str
    ts: datetime
    correlation_id: str
    causation_id: str | None
    command_id: str | None
    source: str  # WEBSOCKET | REST | BOT | WEB
    entity_kind: str
    entity_id: str
    scope: Scope
    dedup_key: str
    payload: dict[str, Any]
    
    @staticmethod
    def new(
        event_type: str,
        source: str,
        entity_kind: str,
        entity_id: str,
        scope: Scope,
        dedup_key: str,
        payload: dict[str, Any],
        correlation_id: str | None = None,
        causation_id: str | None = None,
        command_id: str | None = None,
    ) -> "Event":
        """새 이벤트 생성
        
        주의: ts는 반드시 UTC로 저장 (ADR-010 참조)
        """
        from datetime import timezone
        return Event(
            event_id=str(uuid4()),
            event_type=event_type,
            ts=datetime.now(timezone.utc),  # UTC 명시 (datetime.utcnow() 사용 금지)
            correlation_id=correlation_id or str(uuid4()),
            causation_id=causation_id,
            command_id=command_id,
            source=source,
            entity_kind=entity_kind,
            entity_id=entity_id,
            scope=scope,
            dedup_key=dedup_key,
            payload=payload,
        )
```

## 3.2 Command 클래스

```python
# core/domain/commands.py

from dataclasses import dataclass
from datetime import datetime
from typing import Any
from uuid import uuid4


@dataclass
class Actor:
    """행위자"""
    kind: str  # STRATEGY | USER | SYSTEM
    id: str    # strategy:sma_cross | web:admin | system:reconciler


@dataclass
class Command:
    """명령"""
    command_id: str
    command_type: str
    ts: datetime
    correlation_id: str
    causation_id: str | None
    actor: Actor
    scope: Scope
    idempotency_key: str
    status: str
    priority: int
    payload: dict[str, Any]
    result: dict[str, Any] | None
    last_error: str | None
    
    @staticmethod
    def new(
        command_type: str,
        actor_kind: str,
        actor_id: str,
        scope: Scope,
        payload: dict[str, Any],
        priority: int = 0,
        correlation_id: str | None = None,
        idempotency_key: str | None = None,
    ) -> "Command":
        """새 명령 생성
        
        주의: ts는 반드시 UTC로 저장 (ADR-010 참조)
        """
        from datetime import timezone
        command_id = str(uuid4())
        return Command(
            command_id=command_id,
            command_type=command_type,
            ts=datetime.now(timezone.utc),  # UTC 명시 (datetime.utcnow() 사용 금지)
            correlation_id=correlation_id or str(uuid4()),
            causation_id=None,
            actor=Actor(kind=actor_kind, id=actor_id),
            scope=scope,
            idempotency_key=idempotency_key or command_id,
            status="NEW",
            priority=priority,
            payload=payload,
            result=None,
            last_error=None,
        )
    
    @staticmethod
    def client_order_id(command_id: str) -> str:
        """결정적 client_order_id 생성"""
        return f"ae-{command_id}"
```

## 3.3 Event Store

```python
# core/storage/event_store.py

from sqlalchemy import select, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.dialects.postgresql import insert

from adapters.db.models import EventStoreModel
from core.domain.events import Event


class EventStore:
    """이벤트 저장소"""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def append(self, event: Event) -> bool:
        """
        이벤트 저장 (dedup_key로 중복 제거).
        
        Returns:
            True: 저장 성공
            False: 중복으로 무시됨
        """
        stmt = insert(EventStoreModel).values(
            event_id=event.event_id,
            event_type=event.event_type,
            ts=event.ts,
            correlation_id=event.correlation_id,
            causation_id=event.causation_id,
            command_id=event.command_id,
            source=event.source,
            entity_kind=event.entity_kind,
            entity_id=event.entity_id,
            scope_exchange=event.scope.exchange,
            scope_venue=event.scope.venue,
            scope_account_id=event.scope.account_id,
            scope_symbol=event.scope.symbol,
            scope_mode=event.scope.mode,
            dedup_key=event.dedup_key,
            payload_json=event.payload,
        ).on_conflict_do_nothing(index_elements=["dedup_key"])
        
        result = await self.session.execute(stmt)
        await self.session.commit()
        
        return result.rowcount > 0
    
    async def get_since(self, last_seq: int, limit: int = 1000) -> list[Event]:
        """특정 seq 이후 이벤트 조회"""
        stmt = (
            select(EventStoreModel)
            .where(EventStoreModel.seq > last_seq)
            .order_by(EventStoreModel.seq)
            .limit(limit)
        )
        result = await self.session.execute(stmt)
        return [self._to_event(row) for row in result.scalars()]
    
    def _to_event(self, model: EventStoreModel) -> Event:
        """모델 → 도메인 변환"""
        return Event(
            event_id=str(model.event_id),
            event_type=model.event_type,
            ts=model.ts,
            correlation_id=str(model.correlation_id),
            causation_id=str(model.causation_id) if model.causation_id else None,
            command_id=str(model.command_id) if model.command_id else None,
            source=model.source,
            entity_kind=model.entity_kind,
            entity_id=model.entity_id,
            scope=Scope(
                exchange=model.scope_exchange,
                venue=model.scope_venue,
                account_id=model.scope_account_id,
                symbol=model.scope_symbol,
                mode=model.scope_mode,
            ),
            dedup_key=model.dedup_key,
            payload=model.payload_json,
        )
```

## 3.4 Binance REST Client

```python
# adapters/binance/rest_client.py

import hashlib
import hmac
import time
from decimal import Decimal
from urllib.parse import urlencode

import httpx

from .rate_limiter import RateLimitTracker
from .models import Order, Trade, Position, Balance


class BinanceRestClient:
    """Binance Futures REST API 클라이언트"""
    
    def __init__(
        self,
        base_url: str,
        api_key: str,
        api_secret: str,
    ):
        self.base_url = base_url
        self.api_key = api_key
        self.api_secret = api_secret
        self.rate_tracker = RateLimitTracker()
        self.client = httpx.AsyncClient(timeout=30.0)
    
    async def _request(
        self,
        method: str,
        path: str,
        params: dict | None = None,
        signed: bool = False,
    ) -> dict:
        """API 요청 실행"""
        params = params or {}
        headers = {"X-MBX-APIKEY": self.api_key}
        
        if signed:
            params["timestamp"] = int(time.time() * 1000)
            params["recvWindow"] = 5000
            query = urlencode(params)
            signature = hmac.new(
                self.api_secret.encode(),
                query.encode(),
                hashlib.sha256,
            ).hexdigest()
            params["signature"] = signature
        
        url = f"{self.base_url}{path}"
        
        response = await self.client.request(
            method,
            url,
            params=params,
            headers=headers,
        )
        
        # Rate Limit 추적
        self.rate_tracker.update_from_headers(response.headers)
        
        # 429 처리
        if response.status_code == 429:
            retry_after = int(response.headers.get("Retry-After", 30))
            raise RateLimitError(retry_after=retry_after)
        
        response.raise_for_status()
        return response.json()
    
    async def create_listen_key(self) -> str:
        """listenKey 생성"""
        data = await self._request("POST", "/fapi/v1/listenKey")
        return data["listenKey"]
    
    async def extend_listen_key(self) -> None:
        """listenKey 연장"""
        await self._request("PUT", "/fapi/v1/listenKey")
    
    async def list_trades(
        self,
        symbol: str,
        start_time: int | None = None,
        limit: int = 500,
    ) -> list[Trade]:
        """체결 내역 조회"""
        params = {"symbol": symbol, "limit": limit}
        if start_time:
            params["startTime"] = start_time
        
        data = await self._request(
            "GET", "/fapi/v1/userTrades", params=params, signed=True
        )
        return [Trade.from_api(t) for t in data]
    
    async def list_open_orders(self, symbol: str | None = None) -> list[Order]:
        """오픈 주문 조회"""
        params = {}
        if symbol:
            params["symbol"] = symbol
        
        data = await self._request(
            "GET", "/fapi/v1/openOrders", params=params, signed=True
        )
        return [Order.from_api(o) for o in data]
    
    async def get_position(self, symbol: str) -> Position | None:
        """포지션 조회"""
        data = await self._request(
            "GET", "/fapi/v2/positionRisk", params={"symbol": symbol}, signed=True
        )
        for p in data:
            # Decimal 변환 후 비교 (float 사용 금지)
            if p["symbol"] == symbol and Decimal(p["positionAmt"]) != Decimal("0"):
                return Position.from_api(p)
        return None
    
    async def list_balances(self) -> list[Balance]:
        """잔고 조회"""
        data = await self._request("GET", "/fapi/v2/balance", signed=True)
        # Decimal 변환 후 비교 (float 사용 금지)
        return [Balance.from_api(b) for b in data if Decimal(b["balance"]) > Decimal("0")]
    
    async def place_order(
        self,
        symbol: str,
        side: str,
        order_type: str,
        quantity: Decimal,
        price: Decimal | None = None,
        stop_price: Decimal | None = None,
        client_order_id: str | None = None,
        reduce_only: bool = False,
        time_in_force: str = "GTC",
    ) -> Order:
        """주문 생성"""
        params = {
            "symbol": symbol,
            "side": side,
            "type": order_type,
            "quantity": str(quantity),
        }
        
        if client_order_id:
            params["newClientOrderId"] = client_order_id
        if price:
            params["price"] = str(price)
        if stop_price:
            params["stopPrice"] = str(stop_price)
        if reduce_only:
            params["reduceOnly"] = "true"
        if order_type == "LIMIT":
            params["timeInForce"] = time_in_force
        
        data = await self._request(
            "POST", "/fapi/v1/order", params=params, signed=True
        )
        return Order.from_api(data)
    
    async def cancel_order(
        self,
        symbol: str,
        order_id: str | None = None,
        client_order_id: str | None = None,
    ) -> Order:
        """주문 취소"""
        params = {"symbol": symbol}
        if order_id:
            params["orderId"] = order_id
        if client_order_id:
            params["origClientOrderId"] = client_order_id
        
        data = await self._request(
            "DELETE", "/fapi/v1/order", params=params, signed=True
        )
        return Order.from_api(data)
    
    async def cancel_all_orders(self, symbol: str) -> int:
        """모든 주문 취소"""
        data = await self._request(
            "DELETE", "/fapi/v1/allOpenOrders", params={"symbol": symbol}, signed=True
        )
        return data.get("code", 200)  # 200 = 성공
```

## 3.5 Bot Main Loop

```python
# bot/bootstrap.py

import asyncio
import structlog

from core.config import get_settings, TradingMode
from core.storage import EventStore, CommandStore, ConfigStore
from adapters.binance import BinanceRestClient, BinanceWebSocketListener
from adapters.db import get_session
from bot.websocket import WebSocketMessageHandler
from bot.reconciler import HybridReconciler
from bot.projector import Projector
from bot.executor import CommandExecutor
from bot.command import CommandClaimer, CommandProcessor
from bot.strategy import StrategyRunner, build_strategy_context

logger = structlog.get_logger()


async def main():
    """Bot 메인 함수"""
    settings = get_settings()
    
    logger.info(
        "Starting AlphaEngine Bot",
        mode=settings.mode.value,
        symbol=settings.symbol,
    )
    
    # DB 연결
    async with get_session() as session:
        # 저장소 초기화
        event_store = EventStore(session)
        command_store = CommandStore(session)
        config_store = ConfigStore(session)
        
        # Binance 클라이언트
        rest_client = BinanceRestClient(
            base_url=settings.rest_url,
            api_key=settings.api_key,
            api_secret=settings.api_secret,
        )
        
        # WebSocket 핸들러
        ws_handler = WebSocketMessageHandler(event_store, settings.scope)
        
        # WebSocket 리스너
        ws_listener = BinanceWebSocketListener(
            ws_url=settings.ws_url,
            rest_client=rest_client,
            on_message=ws_handler.handle,
            on_state_change=lambda s: on_ws_state_change(s, event_store),
        )
        
        # 컴포넌트 초기화
        reconciler = HybridReconciler(
            rest_client=rest_client,
            event_store=event_store,
            ws_listener=ws_listener,
            scope=settings.scope,
        )
        
        projector = Projector(session, event_store)
        
        executor = CommandExecutor(
            rest_client=rest_client,
            event_store=event_store,
            scope=settings.scope,
        )
        
        command_claimer = CommandClaimer(command_store)
        command_processor = CommandProcessor(executor)
        
        strategy_runner = StrategyRunner(
            strategy_name=settings.strategy_name,
            strategy_params=settings.strategy_params,
            command_store=command_store,
            state_store=config_store,
        )
        
        # 초기화
        logger.info("Loading strategy", name=settings.strategy_name)
        await strategy_runner.load()
        
        logger.info("Starting WebSocket listener")
        await ws_listener.start()
        
        logger.info("Running initial reconcile")
        await reconciler.full_reconcile()
        
        logger.info("Bot started, entering main loop")
        
        # 메인 루프
        await run_main_loop(
            event_store=event_store,
            command_store=command_store,
            config_store=config_store,
            projector=projector,
            reconciler=reconciler,
            strategy_runner=strategy_runner,
            command_claimer=command_claimer,
            command_processor=command_processor,
            scope=settings.scope,
        )


async def run_main_loop(
    event_store: EventStore,
    command_store: CommandStore,
    config_store: ConfigStore,
    projector: Projector,
    reconciler: HybridReconciler,
    strategy_runner: StrategyRunner,
    command_claimer: CommandClaimer,
    command_processor: CommandProcessor,
    scope: Scope,
):
    """메인 루프"""
    last_reconcile = 0
    reconcile_interval = 30  # 초
    
    while True:
        try:
            # 1. 새 이벤트 → Projection 반영
            await projector.apply_pending_events()
            
            # 2. Web에서 발행한 Command 처리
            command = await command_claimer.claim_one()
            if command:
                await command_processor.process(command)
            
            # 3. 엔진 모드 확인
            engine_config = await config_store.get("engine")
            engine_mode = engine_config.get("mode", "RUNNING")
            
            if engine_mode == "RUNNING":
                # 4. 전략 실행
                ctx = await build_strategy_context(
                    projector=projector,
                    state_store=config_store,
                    scope=scope,
                    engine_mode=engine_mode,
                )
                
                new_commands = await strategy_runner.on_tick(ctx)
                
                # 5. 전략 Command 처리
                for cmd in new_commands:
                    await command_store.insert(cmd)
                    await command_processor.process(cmd)
            
            # 6. Reconcile (주기적)
            now = time.time()
            if now - last_reconcile > reconcile_interval:
                await reconciler.tick()
                last_reconcile = now
            
            # 7. Config 변경 감지
            await check_config_changes(config_store)
            
            await asyncio.sleep(0.1)  # tick 간격
            
        except Exception as e:
            logger.error("Main loop error", error=str(e))
            await asyncio.sleep(1)


if __name__ == "__main__":
    asyncio.run(main())
```

------------------------------------------------------------------------

# 4. 설정 관리

AlphaEngine v2는 3단계 설정 관리 방식을 사용한다.

| 분류 | 저장 위치 | 내용 |
|------|----------|------|
| **보안 정보** | secrets.yaml (git ignore) | API Key, Secret, JWT Secret, 모드 선택 |
| **런타임 설정** | DB config_store | 전략, 리스크, 심볼 등 |
| **고정 상수** | 하드코딩 (constants.py) | Binance URL, 기본값 |

## 4.1 secrets.yaml.example

```yaml
# =============================================================================
# AlphaEngine v2 보안 설정
# =============================================================================
# 이 파일을 config/secrets.yaml로 복사하고 실제 값을 입력하세요.
# secrets.yaml은 반드시 .gitignore에 추가하세요!

# -----------------------------------------------------------------------------
# 모드 설정
# -----------------------------------------------------------------------------
# production: 실거래
# testnet: Binance Testnet
mode: testnet

# -----------------------------------------------------------------------------
# Binance API - Production
# -----------------------------------------------------------------------------
production:
  api_key: "your_production_api_key"
  api_secret: "your_production_api_secret"

# -----------------------------------------------------------------------------
# Binance API - Testnet
# -----------------------------------------------------------------------------
testnet:
  api_key: "your_testnet_api_key"
  api_secret: "your_testnet_api_secret"

# -----------------------------------------------------------------------------
# Web 보안
# -----------------------------------------------------------------------------
web:
  secret_key: "your_jwt_secret_key_here"
```

## 4.2 하드코딩 상수 (constants.py)

```python
# core/constants.py

"""
하드코딩 상수 - 변경될 일이 거의 없는 고정값

중요: 경로는 반드시 pathlib.Path 사용 (Windows/Linux 크로스 플랫폼)
"""

from pathlib import Path


# 프로젝트 루트 (이 파일 기준 2단계 상위: core/constants.py → alphaengine/)
PROJECT_ROOT = Path(__file__).resolve().parent.parent


class BinanceEndpoints:
    """Binance API 엔드포인트"""
    
    # Production
    PROD_REST_URL = "https://fapi.binance.com"
    PROD_WS_URL = "wss://fstream.binance.com"
    
    # Testnet
    TEST_REST_URL = "https://testnet.binancefuture.com"
    TEST_WS_URL = "wss://stream.binancefuture.com"


class Defaults:
    """기본값 상수"""
    
    EXCHANGE = "BINANCE"
    VENUE = "FUTURES"
    ACCOUNT_ID = "main"
    
    WEB_HOST = "127.0.0.1"
    WEB_PORT = 8000
    
    LOG_LEVEL = "INFO"
    POLL_INTERVAL_SEC = 30


class Paths:
    """프로젝트 경로 상수 (pathlib 사용 - OS 독립적)"""
    
    # 디렉토리
    CONFIG_DIR = PROJECT_ROOT / "config"
    DATA_DIR = PROJECT_ROOT / "data"
    
    # 설정 파일
    SECRETS_FILE = CONFIG_DIR / "secrets.yaml"
    
    # DB 파일
    PROD_DB = DATA_DIR / "alphaengine_prod.db"
    TEST_DB = DATA_DIR / "alphaengine_test.db"
```

## 4.3 Settings 클래스

```python
# core/config/settings.py

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Optional

import yaml

from core.constants import BinanceEndpoints, Defaults, Paths


class TradingMode(str, Enum):
    PRODUCTION = "production"
    TESTNET = "testnet"


@dataclass
class Secrets:
    """보안 설정 (secrets.yaml에서 로드)"""
    mode: TradingMode
    api_key: str
    api_secret: str
    web_secret_key: str


@dataclass
class ExchangeConfig:
    """거래소 연결 설정"""
    rest_url: str
    ws_url: str
    api_key: str
    api_secret: str


class Settings:
    """애플리케이션 설정
    
    중요: 모든 경로는 pathlib.Path 타입 (Windows/Linux 크로스 플랫폼)
    """
    
    def __init__(self, secrets_path: Path | None = None):
        # 기본값: Paths.SECRETS_FILE 사용
        if secrets_path is None:
            secrets_path = Paths.SECRETS_FILE
        self._secrets = self._load_secrets(secrets_path)
    
    def _load_secrets(self, path: Path) -> Secrets:
        """secrets.yaml 로드"""
        # pathlib의 read_text 사용 (인코딩 명시)
        content = path.read_text(encoding="utf-8")
        data = yaml.safe_load(content)
        
        mode = TradingMode(data["mode"])
        creds = data[mode.value]
        
        return Secrets(
            mode=mode,
            api_key=creds["api_key"],
            api_secret=creds["api_secret"],
            web_secret_key=data["web"]["secret_key"],
        )
    
    @property
    def mode(self) -> TradingMode:
        return self._secrets.mode
    
    @property
    def db_path(self) -> Path:
        """현재 모드의 DB 경로 (Path 타입)"""
        if self.mode == TradingMode.PRODUCTION:
            return Paths.PROD_DB
        return Paths.TEST_DB
    
    @property
    def exchange_config(self) -> ExchangeConfig:
        """현재 모드의 거래소 설정"""
        if self.mode == TradingMode.PRODUCTION:
            return ExchangeConfig(
                rest_url=BinanceEndpoints.PROD_REST_URL,
                ws_url=BinanceEndpoints.PROD_WS_URL,
                api_key=self._secrets.api_key,
                api_secret=self._secrets.api_secret,
            )
        return ExchangeConfig(
            rest_url=BinanceEndpoints.TEST_REST_URL,
            ws_url=BinanceEndpoints.TEST_WS_URL,
            api_key=self._secrets.api_key,
            api_secret=self._secrets.api_secret,
        )
    
    @property
    def web_secret_key(self) -> str:
        return self._secrets.web_secret_key


# 전역 설정 인스턴스
_settings: Optional[Settings] = None


def get_settings(secrets_path: Path | None = None) -> Settings:
    """설정 싱글턴
    
    Args:
        secrets_path: secrets.yaml 경로 (Path 타입). None이면 기본 경로 사용.
    """
    global _settings
    if _settings is None:
        _settings = Settings(secrets_path)
    return _settings
```

## 4.4 DB config_store (런타임 설정)

```python
# core/config/config_store.py

import json
from dataclasses import dataclass
from typing import Any, Optional

from core.constants import Defaults


@dataclass
class RuntimeConfig:
    """런타임 설정 (DB config_store에서 로드)"""
    
    # 거래 범위
    symbol: str = "XRPUSDT"
    account_id: str = Defaults.ACCOUNT_ID
    
    # 전략
    strategy_name: str = "sma_cross"
    strategy_timeframe: str = "5m"
    strategy_params: dict = None
    
    # 리스크
    max_risk_per_trade: float = 0.02
    daily_loss_limit: float = 0.05
    
    # 엔진
    poll_interval_sec: int = Defaults.POLL_INTERVAL_SEC
    
    # 로깅
    log_level: str = Defaults.LOG_LEVEL
    
    def __post_init__(self):
        if self.strategy_params is None:
            self.strategy_params = {"fast": 10, "slow": 20}


class ConfigStore:
    """DB에서 런타임 설정 관리"""
    
    def __init__(self, db_session):
        self.db = db_session
    
    async def load(self) -> RuntimeConfig:
        """DB에서 설정 로드"""
        row = await self.db.execute(
            "SELECT value_json FROM config_store WHERE key = 'runtime'"
        )
        result = row.fetchone()
        
        if result is None:
            # 기본값 생성
            config = RuntimeConfig()
            await self.save(config)
            return config
        
        data = json.loads(result[0])
        return RuntimeConfig(
            symbol=data.get("trading", {}).get("symbol", "XRPUSDT"),
            account_id=data.get("trading", {}).get("account_id", Defaults.ACCOUNT_ID),
            strategy_name=data.get("strategy", {}).get("name", "sma_cross"),
            strategy_timeframe=data.get("strategy", {}).get("timeframe", "5m"),
            strategy_params=data.get("strategy", {}).get("params", {"fast": 10, "slow": 20}),
            max_risk_per_trade=data.get("risk", {}).get("max_risk_per_trade", 0.02),
            daily_loss_limit=data.get("risk", {}).get("daily_loss_limit", 0.05),
            poll_interval_sec=data.get("engine", {}).get("poll_interval_sec", 30),
            log_level=data.get("logging", {}).get("level", "INFO"),
        )
    
    async def save(self, config: RuntimeConfig) -> None:
        """DB에 설정 저장"""
        data = {
            "trading": {
                "symbol": config.symbol,
                "account_id": config.account_id,
            },
            "strategy": {
                "name": config.strategy_name,
                "timeframe": config.strategy_timeframe,
                "params": config.strategy_params,
            },
            "risk": {
                "max_risk_per_trade": config.max_risk_per_trade,
                "daily_loss_limit": config.daily_loss_limit,
            },
            "engine": {
                "poll_interval_sec": config.poll_interval_sec,
            },
            "logging": {
                "level": config.log_level,
            },
        }
        
        await self.db.execute("""
            INSERT INTO config_store (key, value_json, version, updated_by)
            VALUES ('runtime', ?, 1, 'system')
            ON CONFLICT(key) DO UPDATE SET
                value_json = excluded.value_json,
                version = config_store.version + 1,
                updated_at = datetime('now'),
                updated_by = 'system'
        """, (json.dumps(data),))
        await self.db.commit()
```

------------------------------------------------------------------------

# 5. 구현 순서 (Foundation First 방식)

**개발 철학**: "다시 들여다보지 않아도 되는" 튼튼한 기반을 먼저 구축

자세한 내용은 `0.AlphaEngine_v2_Immediate_Action_Roadmap.md`의 Implementation Phases 참조.

------------------------------------------------------------------------

## Dev-Phase 0: 핵심 유틸리티 (독립, 외부 의존성 0)

**목표**: 순수 Python, 외부 호출 없음, 100% 단위 테스트 가능

| 모듈 | 설명 |
|------|------|
| `core/constants.py` | 하드코딩 상수 (URL, 기본값) |
| `core/types.py` | Enum, TypedDict, Dataclass |
| `core/config/loader.py` | secrets.yaml 로더 |
| `core/domain/events.py` | Event Envelope, Types |
| `core/domain/commands.py` | Command Envelope, Types |
| `core/utils/dedup.py` | dedup_key 생성 |
| `core/utils/idempotency.py` | client_order_id 생성 |

**완료 기준**: pytest 100% 통과, 외부 호출 없음

------------------------------------------------------------------------

## Dev-Phase 1: 외부 서비스 어댑터

**목표**: Protocol 정의 → 실제 구현 → Mock 구현

```python
# adapters/interfaces.py
class IExchangeRestClient(Protocol):
    async def get_account_balance(self) -> list[Balance]: ...
    async def place_order(self, order: OrderRequest) -> OrderResult: ...
    async def cancel_order(self, symbol: str, order_id: str) -> bool: ...

class IExchangeWsClient(Protocol):
    async def connect(self) -> None: ...
    async def subscribe_user_data(self, callback: Callable) -> None: ...
```

| 모듈 | 설명 |
|------|------|
| `adapters/interfaces.py` | Protocol 정의 |
| `adapters/binance/rest_client.py` | Binance REST 구현 |
| `adapters/binance/ws_client.py` | Binance WebSocket 구현 |
| `adapters/mock/exchange_client.py` | Mock 거래소 클라이언트 |
| `adapters/db/sqlite_adapter.py` | SQLite 연결 |

**완료 기준**: 단위 테스트 통과, Mock 교체 가능

------------------------------------------------------------------------

## Dev-Phase 2: 시나리오별 E2E 검증 (Testnet)

**목표**: 실제 Binance Testnet에서 핵심 시나리오 동작 확인

### 연결 시나리오
- REST 연결 → 잔고 조회
- WebSocket 연결 → 이벤트 수신
- WebSocket 재연결 → 복구

### 매매 시나리오
- 시장가 매수/매도
- 지정가 주문/취소
- 부분 체결

### 리스크 시나리오
- 손절 (STOP_MARKET)
- 익절 (TAKE_PROFIT_MARKET)

### 장애 시나리오
- API 타임아웃 → client_order_id 복구
- Rate Limit → Retry-After 대기
- WebSocket 끊김 → REST 백업

**완료 기준**: 모든 시나리오 Testnet 성공

------------------------------------------------------------------------

## Dev-Phase 3: Thin Slice

**목표**: 전체 흐름 관통하는 최소 기능

```
secrets.yaml → Binance REST → 잔고 조회 → SQLite 저장 → 로그 출력
```

| 작업 | 설명 |
|------|------|
| DB 스키마 | event_store, command_store, config_store |
| EventStore | append, get_by_id, get_after |
| Thin Slice | 단일 스크립트 동작 확인 |

------------------------------------------------------------------------

## Dev-Phase 4: 스켈레톤 구축

| 모듈 | 설명 |
|------|------|
| `bot/__main__.py` | Bot 진입점 |
| `bot/bootstrap.py` | 설정 로드, 메인 루프 |
| `web/__main__.py` | Web 진입점 |
| `web/app.py` | FastAPI 앱 |

------------------------------------------------------------------------

## Dev-Phase 5: 코어 로직

| 모듈 | 설명 |
|------|------|
| `bot/websocket/listener.py` | WebSocket 이벤트 수신 |
| `bot/reconciler/reconciler.py` | REST 정합 검사 |
| `bot/executor/executor.py` | Command 실행 |
| `bot/projector/projector.py` | Projection 업데이트 |
| `bot/risk/guard.py` | 리스크 가드 |
| `strategies/base.py` | 전략 인터페이스 |

------------------------------------------------------------------------

## Dev-Phase 6: 통합 및 운영

| 작업 | 설명 |
|------|------|
| 통합 테스트 | 전체 E2E |
| Web UI | 대시보드, 설정 |
| 배포 | systemd, nginx |
| Production | Testnet → Production 전환 |

------------------------------------------------------------------------

# 6. 검증 체크리스트

## Dev-Phase 0 완료
- [ ] 모든 core 모듈 pytest 100% 통과
- [ ] 외부 네트워크 호출 없음
- [ ] 타입 힌트 완전

## Dev-Phase 1 완료
- [ ] 모든 어댑터 Protocol 준수
- [ ] Mock 어댑터로 교체 가능
- [ ] 단위 테스트 통과

## Dev-Phase 2 완료
- [ ] Testnet 모든 시나리오 성공
- [ ] 장애 시나리오 복구 확인

## 기능 검증
- [ ] WebSocket 연결/재연결 정상
- [ ] REST Reconcile 정상
- [ ] dedup_key 중복 제거 정상
- [ ] 주문 생성/취소 정상
- [ ] 전략 실행 정상

## 안정성 검증
- [ ] 중복 주문 0건
- [ ] 이벤트 누락 0건
- [ ] Rate Limit 백오프 정상

## 보안 검증
- [ ] API Key secrets.yaml 관리
- [ ] Web HTTPS 적용
- [ ] JWT 인증 적용

------------------------------------------------------------------------

문서 종료
